<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[类别：ios | Marco的杂货铺]]></title>
  <link href="http://marcofeng.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://marcofeng.com/"/>
  <updated>2015-09-11T20:39:40+08:00</updated>
  <id>http://marcofeng.com/</id>
  <author>
    <name><![CDATA[Marco Feng]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[转] 招聘一个靠谱的 iOS]]></title>
    <link href="http://marcofeng.com/blog/2015/09/11/zhao-pin-%5B%3F%5D-ge-kao-pu-de-ios/"/>
    <updated>2015-09-11T20:06:28+08:00</updated>
    <id>http://marcofeng.com/blog/2015/09/11/zhao-pin-[?]-ge-kao-pu-de-ios</id>
    <content type="html"><![CDATA[<p>近一年内陆续面试了不少人了，从面试者到面试官的转变让我对 iOS 招聘有了更多的感受。经过了前段时间的一大波面试，我们终于找到了志同道合的小伙伴，面试也暂时告一段落了。总结下面试人过程中的感受，你也可以读到我们对简历、算法、性格、iOS 基础、底层知识的看法和一些常问的面试题。</p>

<p>&lt;–!more–&gt;</p>

<h2 id="section">一个靠谱的简历</h2>

<p>简历非常能反映一个人的性格和水平，相比于你在学校获得多少奖项，工作经历、项目经历、熟悉的技术等更加关键，如果还有博客和一些 Github 上的项目，好感度++，但记得在去面试前收拾下，我们真的会挨个文件 review 你的开源代码的。我们还喜欢关注一些细节，比如简历里关键字的拼写，看似无关紧要但很能反映出对自己的要求，经常见一个简历中 iOS 这三个字母的拼写就出现 IOS、iOS、ios 三种的，非常不能忍，再列举几个常见问题：</p>

<p>iPhone -&gt; IPHONE IPhone</p>

<p>Xcode -&gt; XCode xcode</p>

<p>Objective-C -&gt; Object-C</p>

<p>JSON -&gt; Json</p>

<p>HTTP -&gt; Http</p>

<p>还有，注意中英文间用一个半角空格隔开，排版会漂亮很多，简历承载的不仅是内容，还有细节和态度，上面这些点往往都反映着面试者的代码风格、做事的认真程度。当然，简历写的很漂亮但面聊之后发现啥都不会的也有，甚至见过来面试上来就跟我说简历是假的，就想求个面试机会这种 - -</p>

<h2 id="section-1">面试</h2>

<p>别迟到，别迟到，别迟到，重要的事说三遍。有变动提前通知 HR，碰到过临时有事没来，和谁都不说一声，打电话过去还要求改个时间的，这种直接拜拜。
面试时最好准备纸、笔、简历，可能用不上，但很能体现认真程度。有条件的话带着 Mac 和源码，手机中装好所有在简历中出现的 App。</p>

<h2 id="section-2">关于算法</h2>

<p>我们是实用主义，iOS 开发中很少需要自己写复杂的算法，所以不在面试考核标准中。</p>

<h2 id="section-3">代码规范</h2>

<p>这是一个重点考察项，曾经在微博上发过一个风格纠错题：</p>

<p><img src="/images/zhaopinyige/51530583jw1eqo0v3zgr8j20qc0f2dja.jpg" alt="1" /></p>

<p>也曾在面试时让人当场改过，槽点不少，能够有 10 处以上修改的就基本达到标准了（处女座的人在这方面表现都很优秀</p>

<h2 id="section-4">一个区分度很大的面试题</h2>

<p>考察一个面试者基础咋样，基本上问一个 @property 就够了：</p>

<p>@property 后面可以有哪些修饰符？</p>

<p>什么情况使用 weak 关键字，相比 assign 有什么不同？</p>

<p>怎么用 copy 关键字？</p>

<p>这个写法会出什么问题： @property (copy) NSMutableArray *array;</p>

<p>如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</p>

<p>这一套问题区分度比较大，如果上面的问题都能回答正确，可以延伸问更深入点的：</p>

<p>@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</p>

<p>@protocol 和 category 中如何使用 @property</p>

<p>runtime 如何实现 weak 属性</p>

<p>每个人擅长的领域不一样，我们一般会从简历上找自己写擅长的技术聊，假如自己并不是很熟，最好别写出来或扯出来，万一面试官刚好非常精通这里就露馅了。</p>

<h2 id="checklist">Checklist</h2>

<p>总结过些面试题，没坚持下去，后来把这些当 checklist，面试的时候实在没话聊的时候做个提醒，语言、框架、运行机制性质的：</p>

<p>[※]@property中有哪些属性关键字？</p>

<p>[※]weak属性需要在dealloc中置nil么？</p>

<p>[※※]@synthesize和@dynamic分别有什么作用？</p>

<p>[※※※]ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</p>

<p>[※※※]用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</p>

<p>[※※※]@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？</p>

<p>[※※※※※]在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</p>

<p>[※※]objc中向一个nil对象发送消息将会发生什么？</p>

<p>[※※※]objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？</p>

<p>[※※※]什么时候会报unrecognized selector的异常？</p>

<p>[※※※※]一个objc对象如何进行内存布局？（考虑有父类的情况）</p>

<p>[※※※※]一个objc对象的isa的指针指向什么？有什么作用？</p>

<p>[※※※※]下面的代码输出什么？</p>

<pre><code>@implementation Son : Father
- (id)init
{
    self = [super init];
    if (self) {
        NSLog(@"%@", NSStringFromClass([self class]));
        NSLog(@"%@", NSStringFromClass([super class]));
    }
    return self;
}
@end
</code></pre>

<p>[※※※※]runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）</p>

<p>[※※※※]使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？</p>

<p>[※※※※※]objc中的类方法和实例方法有什么本质区别和联系？</p>

<p>[※※※※※]_objc_msgForward函数是做什么的，直接调用它将会发生什么？</p>

<p>[※※※※※]runtime如何实现weak变量的自动置nil？</p>

<p>[※※※※※]能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</p>

<p>[※※※]runloop和线程有什么关系？</p>

<p>[※※※]runloop的mode作用是什么？</p>

<p>[※※※※]以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</p>

<p>[※※※※※]猜想runloop内部是如何实现的？</p>

<p>[※]objc使用什么机制管理对象内存？</p>

<p>[※※※※]ARC通过什么方式帮助开发者管理内存？</p>

<p>[※※※※]不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）</p>

<p>[※※※※]BAD_ACCESS在什么情况下出现？</p>

<p>[※※※※※]苹果是如何实现autoreleasepool的？</p>

<p>[※※]使用block时什么情况会发生引用循环，如何解决？</p>

<p>[※※]在block内如何修改block外部变量？</p>

<p>[※※※]使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？</p>

<p>[※※]GCD的队列（dispatch_queue_t）分哪两种类型？</p>

<p>[※※※※]如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</p>

<p>[※※※※]dispatch_barrier_async的作用是什么？</p>

<p>[※※※※※]苹果为什么要废弃dispatch_get_current_queue？</p>

<p>[※※※※※]以下代码运行结果如何？</p>

<pre><code>- (void)viewDidLoad
{
    [super viewDidLoad];
    NSLog(@"1");
    dispatch_sync(dispatch_get_main_queue(), ^{
        NSLog(@"2");
    });
    NSLog(@"3");
}
</code></pre>

<p>[※※]addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？</p>

<p>[※※※]如何手动触发一个value的KVO</p>

<p>[※※※]若一个类有实例变量NSString *_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？</p>

<p>[※※※※]KVC的keyPath中的集合运算符如何使用？</p>

<p>[※※※※]KVC和KVO的keyPath一定是属性么？</p>

<p>[※※※※※]如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？</p>

<p>[※※※※※]apple用什么方式实现对一个对象的KVO？</p>

<p>[※※]IBOutlet连出来的视图属性为什么可以被设置成weak?</p>

<p>[※※※※※]IB中User Defined Runtime Attributes如何使用？</p>

<p>[※※※]如何调试BAD_ACCESS错误</p>

<p>[※※※]lldb（gdb）常用的调试命令？</p>

<p>这些小题可以做为讨论的入口，根据面试者的回答再继续聊下去。其中一些题比较底层，是留给屌屌的面试者或者试探评级用的，一般情况并不是重点的考察内容。</p>

<h2 id="section-5">业务能力</h2>

<p>毕竟平常的工作内容不是 runtime、runloop，不怎么会用到底层的黑魔法，80% 的时间都是和搭建页面、写业务逻辑、网络请求打交道。</p>

<p>要求面试者能够熟练构建 UI，我会找一个面试者做过的页面让他分析下页面结构、约束或者 frame 布局的连法和计算方法；有时也会让面试者说说 UITableView 常用的几个 delegate 和 data source 代理方法，动态 Cell 高度计算什么的；接下来，在手机里随便找一个 App 的页面，让面试者当场说说如果是他写应该用哪些 UI 组件和布局方式等。问几个问题后就能大概了解业务能力了，我们这边重度使用 IB 和 AutoLayout，假如面试者依然使用代码码 UI 也到没关系，有“从良”意愿就很好~</p>

<p>程序架构和一些设计模式如果面试者自己觉得还不错的话也会聊聊，但跪求别说 Singleton 了，用的越多对水平就越表示怀疑。对设计模式自信的我一般问一个问题，抽象工厂模式在 Cocoa SDK 中哪些类中体现？</p>

<p>架构上 MVC 还是 MVVM 还是 MVP 神马的到是可以聊聊各自的见解，反正也没有正确答案，只要别搞的太离谱就行，比如有的人说网络请求和数据库的操作最好放到 UIView 的子类里面干。</p>

<p>网络请求、数据库等各家都有成熟的封装，基本知道咋用就行。除此之外，我们还会顺带的问下除了 iOS 开发外，还会什么其他编程语言、或者熟悉哪种脚本语言和 Terminal 操作等，甚至还问问是如何翻墙- -，相信这些技能都是很重要的。</p>

<h2 id="section-6">性格</h2>

<p>大家都是写程序的，没啥必要用奇怪的、很难的问题难为对方，更关键的还是性格，和 Team 的风格是不是和的来。一个心态良好的面试者需要有个平常心，不傲娇也不跪舔，表达要正常，经常遇到问一个问题后一两分钟一直处于沉思状态，一句话不说，交流像挤牙膏一样，很是憋屈；还有非常屌屌的，明明不懂仍然强行据理力争，镇得住面试官也罢，撞枪口上就别怪不客气了- - 。决定要不要一个人基本上聊 5 分钟就可以确定了，喜欢水到渠成的感觉，看对眼了挡都挡不住。</p>

<p>招聘告一段落，后面将会有更精彩的事情发生。最后，再次感谢大家的支持和对我的信任。</p>

<p>原文地址：http://blog.sunnyxx.com/2015/07/04/ios-interview/</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[转] sizeThatFits and sizeToFit]]></title>
    <link href="http://marcofeng.com/blog/2015/09/11/sizethatfits-and-sizetofit/"/>
    <updated>2015-09-11T17:36:30+08:00</updated>
    <id>http://marcofeng.com/blog/2015/09/11/sizethatfits-and-sizetofit</id>
    <content type="html"><![CDATA[<p>sizeThatFits and sizeToFit是UIView的两个方法, 官方文档上说：</p>

<pre><code>- (CGSize)sizeThatFits:(CGSize)size;
</code></pre>

<p>作用：return ‘best’ size to fit given size. does not actually resize view. Default is return existing view size</p>

<pre><code>- (void)sizeToFit;
</code></pre>

<p>作用： calls sizeThatFits: with current view bounds and changes bounds size.</p>

<!--more-->
<p>example:</p>

<pre><code>- (void)viewDidLoad
{
    [super viewDidLoad];
    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 200, 100)];
    view.backgroundColor = [UIColor yellowColor];
    UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(5, 5, 0, 0)];
    [label setFont:[UIFont systemFontOfSize:20]];
    label.text = @"hello wdszgrf";
    CGSize sizeThatFits = [label sizeThatFits:CGSizeZero];
    NSLog(@"---- %f  %f ----", sizeThatFits.width, sizeThatFits.height);   
    // output:  ---- 117.000000  24.000000 ----

    NSLog(@"**** %f  %f ****", label.frame.size.width, label.frame.size.height);   
    // output:  **** 0.000000  0.000000 **** 说明sizeThatSize并没有改变原始label的大小
 
    [label sizeToFit];  // 这样搞就直接改变了这个label的宽和高，使它根据上面字符串的大小做合适的改变
    [label setCenter:CGPointMake(80, 50)];
    NSLog(@"==== %f %f ====", label.frame.size.width, label.frame.size.height);  	
    // output:   ==== 117.000000 24.000000 ==== 

    [view addSubview:label];
    [self.view addSubview:view];
}
</code></pre>

<p>原文地址：http://liuxing8807.blog.163.com/blog/static/9703530520134381526554/</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[转] iOS开发之AsyncSocket使用教程]]></title>
    <link href="http://marcofeng.com/blog/2015/09/11/ioskai-fa-zhi-asyncsocketshi-yong-jiao-cheng/"/>
    <updated>2015-09-11T17:22:59+08:00</updated>
    <id>http://marcofeng.com/blog/2015/09/11/ioskai-fa-zhi-asyncsocketshi-yong-jiao-cheng</id>
    <content type="html"><![CDATA[<p>用socket可以实现像QQ那样发送即时消息的功能。客户端和服务端需要建立长连接，在长连接的情况下，发送消息。客户端可以发送心跳包来检测长连接。</p>

<p>在iOS开发中使用socket，一般都是用第三方库AsyncSocket，不得不承认这个库确实很强大。下载地址 <a href="https://github.com/robbiehanson/CocoaAsyncSocket.git">CocoaAsyncSocket</a>
。</p>

<p>使用AsyncSocket的时候可以做一层封装，根据需求提供几个接口出来。比如：连接、断开连接、发送消息等等。还有接受消息，接受到的消息可以通过通知、代理、block等传出去。</p>

<p>简单介绍一下对AsyncSocket使用.一般来说，一个用户只需要建立一个socket长连接，所以可以用单例类方便使用。</p>

<!--more-->

<p>定义单例类：LGSocketServe</p>

<p>LGSocketServe.h</p>

<pre><code>//
//  LGSocketServe.h
//  AsyncSocketDemo
//
//  Created by ligang on 15/4/3.
//  Copyright (c) 2015年 ligang. All rights reserved.
//

#import &lt;Foundation/Foundation.h&gt;
#import "AsyncSocket.h"

@interface LGSocketServe : NSObject&lt;AsyncSocketDelegate&gt;

+ (LGSocketServe *)sharedSocketServe;


@end
</code></pre>

<p>LGSocketServe.m</p>

<pre><code>//
//  LGSocketServe.m
//  AsyncSocketDemo
//
//  Created by ligang on 15/4/3.
//  Copyright (c) 2015年 ligang. All rights reserved.
//

#import "LGSocketServe.h"

@implementation LGSocketServe


static LGSocketServe *socketServe = nil;

#pragma mark public static methods


+ (LGSocketServe *)sharedSocketServe {
    @synchronized(self) {
        if(socketServe == nil) {
            socketServe = [[[self class] alloc] init];
        }
    }
    return socketServe;
}


+(id)allocWithZone:(NSZone *)zone
{
    @synchronized(self)
    {
        if (socketServe == nil)
        {
            socketServe = [super allocWithZone:zone];
            return socketServe;
        }
    }
    return nil;
}   


@end
</code></pre>

<p>建立socket长连接</p>

<p>LGSocketServe.h</p>

<pre><code>@property (nonatomic, strong) AsyncSocket         *socket;       // socket

//  socket连接
- (void)startConnectSocket;
</code></pre>

<p>LGSocketServe.m</p>

<pre><code>//自己设定
#define HOST @"192.168.0.1"
#define PORT 8080

//设置连接超时
#define TIME_OUT 20

- (void)startConnectSocket
{
    self.socket = [[AsyncSocket alloc] initWithDelegate:self];
    [self.socket setRunLoopModes:[NSArray arrayWithObject:NSRunLoopCommonModes]];
    if ( ![self SocketOpen:HOST port:PORT] )
    {

    }

}

- (NSInteger)SocketOpen:(NSString*)addr port:(NSInteger)port
{

    if (![self.socket isConnected])
    {
        NSError *error = nil;
        [self.socket connectToHost:addr onPort:port withTimeout:TIME_OUT error:&amp;error];
    }

    return 0;
}
</code></pre>

<p>宏定义一下HOST、PORT、TIME_OUT，实现startConnectSocket方法。这个时候要设置一下AsyncSocket的代理AsyncSocketDelegate。当长连接成功之后会调用：</p>

<pre><code>- (void)onSocket:(AsyncSocket *)sock didConnectToHost:(NSString *)host port:(UInt16)port
{
    //这是异步返回的连接成功，
    NSLog(@"didConnectToHost");
}
</code></pre>

<p>心跳</p>

<p>LGSocketServe.h</p>

<pre><code>@property (nonatomic, retain) NSTimer             *heartTimer;   // 心跳计时器
</code></pre>

<p>LGSocketServe.m</p>

<pre><code>- (void)onSocket:(AsyncSocket *)sock didConnectToHost:(NSString *)host port:(UInt16)port
{
    //这是异步返回的连接成功，
    NSLog(@"didConnectToHost");

    //通过定时器不断发送消息，来检测长连接
    self.heartTimer = [NSTimer scheduledTimerWithTimeInterval:2 target:self selector:@selector(checkLongConnectByServe) userInfo:nil repeats:YES];
    [self.heartTimer fire];
}

// 心跳连接
-(void)checkLongConnectByServe{

    // 向服务器发送固定可是的消息，来检测长连接
    NSString *longConnect = @"connect is here";
    NSData   *data  = [longConnect dataUsingEncoding:NSUTF8StringEncoding];
    [self.socket writeData:data withTimeout:1 tag:1];
}
</code></pre>

<p>在连接成功的回调方法里，启动定时器，每隔2秒向服务器发送固定的消息来检测长连接。（这个根据服务器的需要就可以了）</p>

<p>断开连接</p>

<p>1，用户手动断开连接</p>

<p>LGSocketServe.h</p>

<pre><code>// 断开socket连接
-(void)cutOffSocket;
</code></pre>

<p>LGSocketServe.m</p>

<pre><code>-(void)cutOffSocket
{
    self.socket.userData = SocketOfflineByUser;
    [self.socket disconnect];
}
</code></pre>

<p>cutOffSocket是用户断开连接之后，不在尝试重新连接。</p>

<p>2，wifi断开，socket断开连接</p>

<p>LGSocketServe.m</p>

<pre><code>- (void)onSocket:(AsyncSocket *)sock willDisconnectWithError:(NSError *)err
{

    NSLog(@" willDisconnectWithError %ld   err = %@",sock.userData,[err description]);
    if (err.code == 57) {
        self.socket.userData = SocketOfflineByWifiCut;
    }

}
</code></pre>

<p>wifi断开之后，会回调onSocket:willDisconnectWithError:方法，err.code == 57，这个时候设置self.socket.userData = SocketOfflineByWifiCut。</p>

<p>重新连接</p>

<p>socket断开之后会回调：</p>

<p>LGSocketServe.m</p>

<pre><code>- (void)onSocketDidDisconnect:(AsyncSocket *)sock
{

    NSLog(@"7878 sorry the connect is failure %ld",sock.userData);

    if (sock.userData == SocketOfflineByServer) {
        // 服务器掉线，重连
        [self startConnectSocket];
    }
    else if (sock.userData == SocketOfflineByUser) {

        // 如果由用户断开，不进行重连
        return;
    }else if (sock.userData == SocketOfflineByWifiCut) {

        // wifi断开，不进行重连
        return;
    }

}
</code></pre>

<p>在onSocketDidDisconnect回调方法里面，会根据self.socket.userData来判断是否需要重新连接。</p>

<p>发送消息</p>

<p>LGSocketServe.h</p>

<pre><code>// 发送消息
- (void)sendMessage:(id)message;
LGSocketServe.m

//设置写入超时 -1 表示不会使用超时
#define WRITE_TIME_OUT -1

- (void)sendMessage:(id)message
{
    //像服务器发送数据
    NSData *cmdData = [message dataUsingEncoding:NSUTF8StringEncoding];
    [self.socket writeData:cmdData withTimeout:WRITE_TIME_OUT tag:1];
}

//发送消息成功之后回调
- (void)onSocket:(AsyncSocket *)sock didWriteDataWithTag:(long)tag
{

}
</code></pre>

<p>发送消息成功之后会调用onSocket:didWriteDataWithTag:,在这个方法里可以进行读取消息。</p>

<p>接受消息</p>

<p>LGSocketServe.m</p>

<pre><code>//设置读取超时 -1 表示不会使用超时
#define READ_TIME_OUT -1

#define MAX_BUFFER 1024

//发送消息成功之后回调
- (void)onSocket:(AsyncSocket *)sock didWriteDataWithTag:(long)tag
{
    //读取消息
    [self.socket readDataWithTimeout:-1 buffer:nil bufferOffset:0 maxLength:MAX_BUFFER tag:0];
}

//接受消息成功之后回调
- (void)onSocket:(AsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag
{
    //服务端返回消息数据量比较大时，可能分多次返回。所以在读取消息的时候，设置MAX_BUFFER表示每次最多读取多少，当data.length &lt; MAX_BUFFER我们认为有可能是接受完一个完整的消息，然后才解析
    if( data.length &lt; MAX_BUFFER )
    {
        //收到结果解析...
        NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableLeaves error:nil];
        NSLog(@"%@",dic);
        //解析出来的消息，可以通过通知、代理、block等传出去

    }


    [self.socket readDataWithTimeout:READ_TIME_OUT buffer:nil bufferOffset:0 maxLength:MAX_BUFFER tag:0];
}
</code></pre>

<p>接受消息后去解析，然后可以通过通知、代理、block等传出去。在onSocket:didReadData:withTag:回调方法里面需要不断读取消息，因为数据量比较大的话，服务器会分多次返回。所以我们需要定义一个MAX_BUFFER的宏，表示每次最多读取多少。当data.length &lt; MAX_BUFFER我们认为有可能是接受完一个完整的消息，然后才解析 。</p>

<p>出错处理</p>

<p>LGSocketServe.m</p>

<pre><code>- (void)onSocket:(AsyncSocket *)sock willDisconnectWithError:(NSError *)err
{
    NSData * unreadData = [sock unreadData]; // ** This gets the current buffer
    if(unreadData.length &gt; 0) {
        [self onSocket:sock didReadData:unreadData withTag:0]; // ** Return as much data that could be collected
    } else {

        NSLog(@" willDisconnectWithError %ld   err = %@",sock.userData,[err description]);
        if (err.code == 57) {
            self.socket.userData = SocketOfflineByWifiCut;
        }
    }

}
</code></pre>

<p>socket出错会回调onSocket:willDisconnectWithError:方法，可以通过unreadData来读取未来得及读取的buffer。</p>

<p>使用</p>

<p>导入#import “LGSocketServe.h”</p>

<pre><code> LGSocketServe *socketServe = [LGSocketServe sharedSocketServe];
//socket连接前先断开连接以免之前socket连接没有断开导致闪退
[socketServe cutOffSocket];
socketServe.socket.userData = SocketOfflineByServer;
[socketServe startConnectSocket];

//发送消息 @"hello world"只是举个列子，具体根据服务端的消息格式
[socketServe sendMessage:@"hello world"];
</code></pre>

<p>以上是AsyncSocket的简单使用，在实际开发过程中依然会碰到很多问题，欢迎加我的微信公众号iOS开发：iOSDevTip，一起讨论AsyncSocket中遇到的问题。</p>

<p>AsyncSocketDemo下载地址：<a href="https://github.com/worldligang/AsyncSocketDemo.git">AsyncSocketDemo</a></p>

<p>原文地址：http://www.superqq.com/blog/2015/04/03/ioskai-fa-zhi-asyncsocketshi-yong-jiao-cheng/</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[转] 手机号码和价格金额有效性判断]]></title>
    <link href="http://marcofeng.com/blog/2015/09/11/shou-ji-hao-ma-he-jie-ge-jin-e-you-xiao-xing-pan-duan/"/>
    <updated>2015-09-11T16:29:32+08:00</updated>
    <id>http://marcofeng.com/blog/2015/09/11/shou-ji-hao-ma-he-jie-ge-jin-e-you-xiao-xing-pan-duan</id>
    <content type="html"><![CDATA[<p>在实际开发过程中，经常会遇到些不能让用户随便地输入手机号码，对输入的手机号码的正确判断；有些输入框只能输入数字，不能输入字母或特殊字符；还有些如价格金额之类的就只能输入数字和小数点且小数点后面保留两位。</p>

<!--more-->
<pre><code>// 手机号码的有效性判断  
  
- (BOOL)isMobileNumber:(NSString *)mobileNum  
{  
    /**  
     * 手机号码  
     * 移动：134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188  
     * 联通：130,131,132,152,155,156,185,186  
     * 电信：133,1349,153,180,189  
     */  
    NSString * MOBILE = @"^1(3[0-9]|5[0-35-9]|8[025-9])\\d{8}$";  
    /**  
     10         * 中国移动：China Mobile  
     11         * 134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188  
     12         */  
    NSString * CM = @"^1(34[0-8]|(3[5-9]|5[017-9]|8[278])\\d)\\d{7}$";  
    /**  
     15         * 中国联通：China Unicom  
     16         * 130,131,132,152,155,156,185,186  
     17         */  
    NSString * CU = @"^1(3[0-2]|5[256]|8[56])\\d{8}$";  
    /**  
     20         * 中国电信：China Telecom  
     21         * 133,1349,153,180,189  
     22         */  
    NSString * CT = @"^1((33|53|8[09])[0-9]|349)\\d{7}$";  
    /**  
     25         * 大陆地区固话及小灵通  
     26         * 区号：010,020,021,022,023,024,025,027,028,029  
     27         * 号码：七位或八位  
     28         */  
    // NSString * PHS = @"^0(10|2[0-5789]|\\d{3})\\d{7,8}$";  
    /**  
     29         * 国际长途中国区(+86)  
     30         * 区号：+86  
     31         * 号码：十一位  
     32         */  
     NSString * IPH = @"^\\+861(3|5|8)\\d{9}$";  
      
    NSPredicate *regextestmobile = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", MOBILE];  
    NSPredicate *regextestcm = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CM];  
    NSPredicate *regextestcu = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CU];  
    NSPredicate *regextestct = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CT];  
    NSPredicate *regextestiph = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", IPH];  
    if (([regextestmobile evaluateWithObject:mobileNum] == YES)  
        || ([regextestcm evaluateWithObject:mobileNum] == YES)  
        || ([regextestct evaluateWithObject:mobileNum] == YES)  
        || ([regextestcu evaluateWithObject:mobileNum] == YES)  
        || ([regextestiph evaluateWithObject:mobileNum] == YES))  
    {  
        return YES;  
    }  
    else  
    {  
        return NO;  
    }  
}  

//////// 特殊字符的限制输入，价格金额的有效性判断  
#define myDotNumbers     @"0123456789.\n"  
#define myNumbers        @"+0123456789\n"  
  
-(void) createTextFiled {  
      
    textfield1_ = [[UITextField alloc] initWithFrame:CGRectMake(0, 0, 110, 20)];  
    textfield1_.delegate = self;  
    textfield1_.text=@"";  
    textfield1_.keyboardType=UIKeyboardTypePhonePad;  
    textfield1_.textColor=[UIColor redColor];  
    textfield1_.backgroundColor=[UIColor whiteColor];  
    [self.view addSubview:textfield1_];  
    [textfield1_ release];  
      
    textfield2_ = [[UITextField alloc] initWithFrame:CGRectMake(110, 0, 80, 20)];  
    textfield2_.delegate = self;  
    textfield2_.text=@"11";  
    [self.view addSubview:textfield2_];  
    [textfield2_ release];  
      
    textfield3_ = [[UITextField alloc] initWithFrame:CGRectMake(200, 0, 100, 20)];  
    textfield3_.delegate = self;  
    textfield3_.text=@"22";  
    [self.view addSubview:textfield3_];  
    [textfield3_ release];  
}  
  
-(void)showMyMessage:(NSString*)aInfo {  
      
    UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@"提示"  
                                                        message:aInfo  
                                                       delegate:self  
                                              cancelButtonTitle:@"确定"  
                                              otherButtonTitles:nil, nil];  
    [alertView show];  
    [alertView release];  
}  
  
  
- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string {  
    NSCharacterSet *cs;  
    if ([textField isEqual:textfield1_]) {  
        cs = [[NSCharacterSet characterSetWithCharactersInString:myNumbers] invertedSet];  
        NSString *filtered = [[string componentsSeparatedByCharactersInSet:cs] componentsJoinedByString:@""];  
        BOOL basicTest = [string isEqualToString:filtered];  
        if (!basicTest) {  
            [self showMyMessage:@"只能输入数字"];  
            return NO;  
        }  
    }  
    else if ([textField isEqual:textfield2_]) {  
        cs = [[NSCharacterSet characterSetWithCharactersInString:myNumbers] invertedSet];  
        NSString *filtered = [[string componentsSeparatedByCharactersInSet:cs] componentsJoinedByString:@""];  
        BOOL basicTest = [string isEqualToString:filtered];  
        if (!basicTest) {  
            [self showMyMessage:@"只能输入数字"];  
            return NO;  
        }  
    }  
    else if ([textField isEqual:textfield3_]) {  
        NSUInteger nDotLoc = [textField.text rangeOfString:@"."].location;  
        if (NSNotFound == nDotLoc &amp;&amp; 0 != range.location) {  
            cs = [[NSCharacterSet characterSetWithCharactersInString:myDotNumbers] invertedSet];  
        }  
        else {  
            cs = [[NSCharacterSet characterSetWithCharactersInString:myNumbers] invertedSet];  
        }  
        NSString *filtered = [[string componentsSeparatedByCharactersInSet:cs] componentsJoinedByString:@""];  
        BOOL basicTest = [string isEqualToString:filtered];  
        if (!basicTest) {  
              
            [self showMyMessage:@"只能输入数字和小数点"];  
            return NO;  
        }  
        if (NSNotFound != nDotLoc &amp;&amp; range.location &gt; nDotLoc + 3) {  
            [self showMyMessage:@"小数点后最多三位"];  
            return NO;  
        }  
    }  
    return YES;  
}
</code></pre>

<p>原文地址：http://blog.csdn.net/nogodoss/article/details/8147403</p>

]]></content>
  </entry>
  
</feed>
